{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"clojure-lsp # A Language Server for Clojure. Taking a Cursive-like approach of statically analyzing code. homepage \u2022 features \u2022 installation \u2022 settings \u2022 clients \u2022 troubleshooting \u2022 support us Overview # The goal of this project is to bring great editing tools for Clojure to all editors. It aims to work alongside you to help you navigate, identify and fix errors, perform refactors and much more! You will get: Autocomplete Jump to definition Find references Renaming Code actions Errors Automatic ns management Refactorings Code lens Semantic tokens (syntax highlighting) Call hierarchy For all available features, check the features section . Contribution # Contributions to clojure-lsp are very welcome! You can open an issue or a PR and we'd love to help. Building # GraalVM # Every release the native binaries (Windows, Linux and MacOS) are compiled with GraalVM and uploaded. To build a native image with GraalVM: Install the GraalVM 21.0.0 for Java 11 and set the GRAALVM_HOME to the installation dir Install native-image with $GRAALVM_HOME/bin/gu install native-image Run from clojure-lsp project root ./graalvm/native-unix-compile.sh or ./graalvm/native-windows-compile.bat . The build may take some minutes and the result will be a ./clojure-lsp native binary. Jar # Run clojure -X:prod-jar for building the jar. Development # For clojure-lsp development, there are 3 possible ways of finding a bug or implementing a new feature: Create a test for your bug/feature, then implement the code following the test (TDD). clojure-lsp starts a NREPL server if built with clj -X:debug-jar && clj -X:bin , with that it's possible to change the code of a running instance and see the changes on your client in real time. To get the NREPL port, you can check the /tmp/clojure-lsp.*.out log, it will print the NREPL port on server startup or you can get it via server-info custom LSP command. Build clojure-lsp with your changes and test it manually in your client, this is the slowest option, but it makes sense for final tests. For debugging purposes, there is two custom commands server-info and cursor-info . Support the project # clojure-lsp has more than 8.000 lines of code, to keep all of this working, we need to help the community on a lot of issues and implement new features. As a LSP server, this project is the base for Clojure clients like Emacs(lsp-mode), VSCode(Calva) and vim. You can help us keep going and improving it by supporting the project Special thanks to Eccentric-J for the clojure-lsp logo","title":"Overview"},{"location":"#clojure-lsp","text":"A Language Server for Clojure. Taking a Cursive-like approach of statically analyzing code. homepage \u2022 features \u2022 installation \u2022 settings \u2022 clients \u2022 troubleshooting \u2022 support us","title":"clojure-lsp"},{"location":"#overview","text":"The goal of this project is to bring great editing tools for Clojure to all editors. It aims to work alongside you to help you navigate, identify and fix errors, perform refactors and much more! You will get: Autocomplete Jump to definition Find references Renaming Code actions Errors Automatic ns management Refactorings Code lens Semantic tokens (syntax highlighting) Call hierarchy For all available features, check the features section .","title":"Overview"},{"location":"#contribution","text":"Contributions to clojure-lsp are very welcome! You can open an issue or a PR and we'd love to help.","title":"Contribution"},{"location":"#building","text":"","title":"Building"},{"location":"#graalvm","text":"Every release the native binaries (Windows, Linux and MacOS) are compiled with GraalVM and uploaded. To build a native image with GraalVM: Install the GraalVM 21.0.0 for Java 11 and set the GRAALVM_HOME to the installation dir Install native-image with $GRAALVM_HOME/bin/gu install native-image Run from clojure-lsp project root ./graalvm/native-unix-compile.sh or ./graalvm/native-windows-compile.bat . The build may take some minutes and the result will be a ./clojure-lsp native binary.","title":"GraalVM"},{"location":"#jar","text":"Run clojure -X:prod-jar for building the jar.","title":"Jar"},{"location":"#development","text":"For clojure-lsp development, there are 3 possible ways of finding a bug or implementing a new feature: Create a test for your bug/feature, then implement the code following the test (TDD). clojure-lsp starts a NREPL server if built with clj -X:debug-jar && clj -X:bin , with that it's possible to change the code of a running instance and see the changes on your client in real time. To get the NREPL port, you can check the /tmp/clojure-lsp.*.out log, it will print the NREPL port on server startup or you can get it via server-info custom LSP command. Build clojure-lsp with your changes and test it manually in your client, this is the slowest option, but it makes sense for final tests. For debugging purposes, there is two custom commands server-info and cursor-info .","title":"Development"},{"location":"#support-the-project","text":"clojure-lsp has more than 8.000 lines of code, to keep all of this working, we need to help the community on a lot of issues and implement new features. As a LSP server, this project is the base for Clojure clients like Emacs(lsp-mode), VSCode(Calva) and vim. You can help us keep going and improving it by supporting the project Special thanks to Eccentric-J for the clojure-lsp logo","title":"Support the project"},{"location":"CHANGELOG/","text":"Changelog # Unreleased # After project startup, publish all project only diagnostics. This is a approach done by other LSPs to make work features like Project errors . 2021.04.03-18.43.55 # Fix textDocument/workspaceSymbols filter not working on native binaries. Report duplicate linters as default, can be disabled via :linters :clj-kondo :report-duplicates - Fixes #390 Bump rewrite-clj to 1.0.605-alpha to fix exceptions when on clojure files with babashka interpreter on first line. Bump clj-kondo 2021.04.01-20210402.215253-6 to fix bug https://github.com/clj-kondo/clj-kondo/issues/1246 2021.03.30-20.42.34 # Bump clj-londo 2021.03.22-20210327.192113-4 - Fixes #385 Add support for outgoing call hierarchy - Fixes #384 Improve and fix missing completion item kinds. 2021.03.26-23.41.07 # Bump clj-kondo 2021.03.22-20210324.110254-3 - Fixes #382 [graalvm] Fixes Unable to invoke no-args constructor for class org.eclipse.lsp4j.ShowDocumentCapabilities error. Fix/enhance keyword rename - #383 2021.03.24-00.41.55 # Migrate from lein to deps.edn Bump clj-kondo to 2021.03.22 Fix clean-ns sorting according to symbols not brackets - Fixes #380 Fix missing graalvm reflect config for CompletionItemTextEdit - Fixes #381 2021.03.21-23.29.19 # Add code action 'resolve macro as', it requires client to fill the chosen macro and clj-kondo config file. Bump rewrite-clj to 1.0.594-alpha Bump data.json to 2.0.1 Bump lsp4j to 0.11.0 2021.03.18-19.23.41 # Add support for diagnostic tags: deprecated and unnecessary. Fix wrong textDocument/documentHighlight for function local-usages. Use new clj-kondo copy-configs flag to copy hooks during lint. Bunp clj-kondo to fix unused public linter check for :exclude-when-defined-by 2021.03.16-20.28.06 # Fix server not analyzing after a wrong code on cljs files - #367 Rollback incremental didChange adding a new :text-document-sync-kind setting with :full as default. 2021.03.14-23.22.46 # Fix completion inside refers, re-add support for it - Fixes #364 Change range of expression functions clj-kondo diagnostics to avoid collision with function signature. 2021.03.06-17.05.35 # Fix incremental didChange, debouncing distincting by uri, fixing some inconsistent file changes when multiple files are changed at same time (rename, iedit, etc). Make unused-public-var ignore -main public functions. Add :exclude-when-defined-by option to unused-public-var linter, check settings documentation for more information. 2021.03.05-13.35.47 # Fix clojure-lsp lint crash when analyzing specific macros with clj-kondo hooks. Fix didChange for Nvim client. Add new clojure-lsp linter: unused-public-var - Fixes #359 Add option to disable clj-kondo linter, check settings documentation for more details. 2021.03.01-19.18.54 # Bump clj-kondo fixing issues on require form not being analyzed. Fix textDocument/workspaceSymbols to use the query sent by client. 2021.02.27-23.35.55 # Add support to complete full qualified namespaces - Fixes #337 Add :log-path setting to log to a custom file. Avoid exception on code actions when on cljc reader macros - Related to #346 2021.02.26-13.58.48 # Improve clojure-lsp config search checking always home dir considering XDG_CONFIG_HOME and project root up to system root (/) - Fixes #339. Handle incremental text changes on textDocument/didChange notifications following LSP protocol, improving performance for huge files. Add clj-kondo version to --version and server-info. Add new create private function code action. 2021.02.24-14.23.08 # Improve completion performance resolving the item only when documentation is requested Add new thread first/last all code actions 2021.02.21-21.02.51 # Implement support for textDocument/signatureHelp - Fixes #324 Disable notify-references on didChange with a flag notify-references-on-change . Fix completion not working when reader macro on file - Fixes #332 2021.02.19-23.08.40 # Fix duplicated symbols for cljc files on textDocument/documentSymbols - Fixes #328 Add namespace require when completing a unimported namespace - Fixes #309 Fix completion not working for cljc files 2021.02.19-00.19.27 # Fix completion of invalid clojure core (e.g. foo/ ) - Fixes #270 2021.02.17-17.00.45 # Allow find all references across the project of simple keywords Allow specify custom sqlite.db location with sqlite-db-path , default to <project>/.lsp/sqlite.db 2021.02.14-19.46.47 # Removing false positive logs from invalid analysis from clj-kondo macro expand analysis Fix call hierarchy when the reference was not open yet in the editor. Smart re-analyze variable/function references when arguments of the definition were updated. Rollback Macos native image compress until it works for MacOS Big Sur - #322 2021.02.13-18.04.19 # Bump clj-kondo to fix false-positive unresolved-vars Prioritize project analysis on all analysis during find definition - Fixes #318 Compress native binaries with UPX decreasing binary size. 2021.02.12-03.13.12 # Fix completion issues with graalvm native linux binaries when completing local variables. Fix completion exception when completing numbers - Fixes #310 Completion inside a require suggests all available namespaces Change log pattern to /tmp/clojure-lsp.<TIMESTAMP>.out use default temp file. Should fix issues with permissions on tmp folder. 2021.02.11-12.43.06 # Fix auto add ns not working for projects. New code action: Move to let New code action: Change coll to map, list, set or vector 2021.02.10-03.01.19 # Fix config passed to clj-kondo during analysis - Fixes #308 2021.02.09-18.28.06 # Fix auto add ns to check project root and source paths Add alias on copmletion items - Fix completion items for Calva client 2021.02.07-22.51.26 # Fix install-latest-clojure-lsp.sh script - #304 Fix clojure-lsp re-analysing classpath when project contains a keyword starting with a number - #305 Allow clj-kondo to pick up config correctly in mono repos - #303 2021.02.07-03.04.31 # Make release's native binaries executable by default - #299 Improve completion removing the necessity to call completion/resolveItem - #292 New code action: Add suggested alias to namespaces - #302 2021.02.05-03.05.34 # Add support for keyword analysis (definition, references, completion, rename, hover) Reduce jar and binaries size excluding some dependencies (Need to fix a lein issue yet) 2021.02.04-02.08.58 # Fix --version on graalvm native compiled binaries 2021.02.04-01.09.21 # Add integration tests to release process 2021.02.02-14.02.23 # Fix clojure-lsp embedded jar binary during release CI Fix duplicate references on cljc files 2021.02.02-03.06.46 # Add clojure.java.io to known requires - #291 Add manual System/gc after first classpath scan, it should decrease memory after the first startup Add support for Windows GraalVM compiled native binary 2021.02.01-20.37.52 # Add native binaries for Linux and MacOS compiled with GraalVM #267 (Experimental) 2021.01.28-03.03.16 # Fix clj-kondo batch analysis when merging batchs - Fix #284 2021.01.27-21.47.42 # Fix missing printlng and avoid errors for next time (this was causing issues in clients like vim coc) 2021.01.26-22.35.27 # Fix document-symbol after #261 - Fixes #276 Reduce memory usage on startup batch analyzing classpath via clj-kondo. - Fixes #268 2021.01.25-22.56.05 # Do not remove document on textDocument/didClose , related to #264. Fix default project-specs for shadow-cljs to use npx prefix. Fix range of textDocument/hover for definition usages. Fix completionItem/resolve broken after #261. 2021.01.25-17.22.05 # Remove references code-lens from deftest forms Fix completion for alias ns from external deps - Fixes #269 2021.01.22-13.04.28 # Huge refactor https://github.com/clojure-lsp/clojure-lsp/pull/261 which uses clj-kondo analysis / findings output to almost all clojure-lsp features. Should significantly increase performance and startup time Should fix almost all bugs/issues with windows Users since we now rely on clj-kondo analysis Remove all lint configs from clojure-lsp including macro-defs , they should be configured on clj-kondo side now via .clj-kondo/config.edn Move file path on documentation to bottom 2021.01.20-01.39.32 # Fixes args for extract-function refactoring - Fixes #263 2021.01.16-03.28.20 # Check for defintions when finding references with includeDeclaration as true - Fixes #260 Add custom command cursor-info to debugging clojure-lsp. Fix unnecessary new-lines on imports when executing clean-ns 2021.01.14-23.15.54 # Check for the whole line to add-miising-* code actions instead of expect the cursor at the ns to be required/imported - Fixes #258 Return all possible add-missing-* code actions to the same line. 2021.01.14-17.19.10 # Fix add missing import code actions after refactor 2021.01.14-12.44.42 # Fixes #208 2021.01.14-02.30.28 # LSP 3.16: Add support for codeAction/resolve improving performance if client supports it Bump extend lib [CI] Remove auto release, next releases should contain more than one PR/fix","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"After project startup, publish all project only diagnostics. This is a approach done by other LSPs to make work features like Project errors .","title":"Unreleased"},{"location":"CHANGELOG/#20210403-184355","text":"Fix textDocument/workspaceSymbols filter not working on native binaries. Report duplicate linters as default, can be disabled via :linters :clj-kondo :report-duplicates - Fixes #390 Bump rewrite-clj to 1.0.605-alpha to fix exceptions when on clojure files with babashka interpreter on first line. Bump clj-kondo 2021.04.01-20210402.215253-6 to fix bug https://github.com/clj-kondo/clj-kondo/issues/1246","title":"2021.04.03-18.43.55"},{"location":"CHANGELOG/#20210330-204234","text":"Bump clj-londo 2021.03.22-20210327.192113-4 - Fixes #385 Add support for outgoing call hierarchy - Fixes #384 Improve and fix missing completion item kinds.","title":"2021.03.30-20.42.34"},{"location":"CHANGELOG/#20210326-234107","text":"Bump clj-kondo 2021.03.22-20210324.110254-3 - Fixes #382 [graalvm] Fixes Unable to invoke no-args constructor for class org.eclipse.lsp4j.ShowDocumentCapabilities error. Fix/enhance keyword rename - #383","title":"2021.03.26-23.41.07"},{"location":"CHANGELOG/#20210324-004155","text":"Migrate from lein to deps.edn Bump clj-kondo to 2021.03.22 Fix clean-ns sorting according to symbols not brackets - Fixes #380 Fix missing graalvm reflect config for CompletionItemTextEdit - Fixes #381","title":"2021.03.24-00.41.55"},{"location":"CHANGELOG/#20210321-232919","text":"Add code action 'resolve macro as', it requires client to fill the chosen macro and clj-kondo config file. Bump rewrite-clj to 1.0.594-alpha Bump data.json to 2.0.1 Bump lsp4j to 0.11.0","title":"2021.03.21-23.29.19"},{"location":"CHANGELOG/#20210318-192341","text":"Add support for diagnostic tags: deprecated and unnecessary. Fix wrong textDocument/documentHighlight for function local-usages. Use new clj-kondo copy-configs flag to copy hooks during lint. Bunp clj-kondo to fix unused public linter check for :exclude-when-defined-by","title":"2021.03.18-19.23.41"},{"location":"CHANGELOG/#20210316-202806","text":"Fix server not analyzing after a wrong code on cljs files - #367 Rollback incremental didChange adding a new :text-document-sync-kind setting with :full as default.","title":"2021.03.16-20.28.06"},{"location":"CHANGELOG/#20210314-232246","text":"Fix completion inside refers, re-add support for it - Fixes #364 Change range of expression functions clj-kondo diagnostics to avoid collision with function signature.","title":"2021.03.14-23.22.46"},{"location":"CHANGELOG/#20210306-170535","text":"Fix incremental didChange, debouncing distincting by uri, fixing some inconsistent file changes when multiple files are changed at same time (rename, iedit, etc). Make unused-public-var ignore -main public functions. Add :exclude-when-defined-by option to unused-public-var linter, check settings documentation for more information.","title":"2021.03.06-17.05.35"},{"location":"CHANGELOG/#20210305-133547","text":"Fix clojure-lsp lint crash when analyzing specific macros with clj-kondo hooks. Fix didChange for Nvim client. Add new clojure-lsp linter: unused-public-var - Fixes #359 Add option to disable clj-kondo linter, check settings documentation for more details.","title":"2021.03.05-13.35.47"},{"location":"CHANGELOG/#20210301-191854","text":"Bump clj-kondo fixing issues on require form not being analyzed. Fix textDocument/workspaceSymbols to use the query sent by client.","title":"2021.03.01-19.18.54"},{"location":"CHANGELOG/#20210227-233555","text":"Add support to complete full qualified namespaces - Fixes #337 Add :log-path setting to log to a custom file. Avoid exception on code actions when on cljc reader macros - Related to #346","title":"2021.02.27-23.35.55"},{"location":"CHANGELOG/#20210226-135848","text":"Improve clojure-lsp config search checking always home dir considering XDG_CONFIG_HOME and project root up to system root (/) - Fixes #339. Handle incremental text changes on textDocument/didChange notifications following LSP protocol, improving performance for huge files. Add clj-kondo version to --version and server-info. Add new create private function code action.","title":"2021.02.26-13.58.48"},{"location":"CHANGELOG/#20210224-142308","text":"Improve completion performance resolving the item only when documentation is requested Add new thread first/last all code actions","title":"2021.02.24-14.23.08"},{"location":"CHANGELOG/#20210221-210251","text":"Implement support for textDocument/signatureHelp - Fixes #324 Disable notify-references on didChange with a flag notify-references-on-change . Fix completion not working when reader macro on file - Fixes #332","title":"2021.02.21-21.02.51"},{"location":"CHANGELOG/#20210219-230840","text":"Fix duplicated symbols for cljc files on textDocument/documentSymbols - Fixes #328 Add namespace require when completing a unimported namespace - Fixes #309 Fix completion not working for cljc files","title":"2021.02.19-23.08.40"},{"location":"CHANGELOG/#20210219-001927","text":"Fix completion of invalid clojure core (e.g. foo/ ) - Fixes #270","title":"2021.02.19-00.19.27"},{"location":"CHANGELOG/#20210217-170045","text":"Allow find all references across the project of simple keywords Allow specify custom sqlite.db location with sqlite-db-path , default to <project>/.lsp/sqlite.db","title":"2021.02.17-17.00.45"},{"location":"CHANGELOG/#20210214-194647","text":"Removing false positive logs from invalid analysis from clj-kondo macro expand analysis Fix call hierarchy when the reference was not open yet in the editor. Smart re-analyze variable/function references when arguments of the definition were updated. Rollback Macos native image compress until it works for MacOS Big Sur - #322","title":"2021.02.14-19.46.47"},{"location":"CHANGELOG/#20210213-180419","text":"Bump clj-kondo to fix false-positive unresolved-vars Prioritize project analysis on all analysis during find definition - Fixes #318 Compress native binaries with UPX decreasing binary size.","title":"2021.02.13-18.04.19"},{"location":"CHANGELOG/#20210212-031312","text":"Fix completion issues with graalvm native linux binaries when completing local variables. Fix completion exception when completing numbers - Fixes #310 Completion inside a require suggests all available namespaces Change log pattern to /tmp/clojure-lsp.<TIMESTAMP>.out use default temp file. Should fix issues with permissions on tmp folder.","title":"2021.02.12-03.13.12"},{"location":"CHANGELOG/#20210211-124306","text":"Fix auto add ns not working for projects. New code action: Move to let New code action: Change coll to map, list, set or vector","title":"2021.02.11-12.43.06"},{"location":"CHANGELOG/#20210210-030119","text":"Fix config passed to clj-kondo during analysis - Fixes #308","title":"2021.02.10-03.01.19"},{"location":"CHANGELOG/#20210209-182806","text":"Fix auto add ns to check project root and source paths Add alias on copmletion items - Fix completion items for Calva client","title":"2021.02.09-18.28.06"},{"location":"CHANGELOG/#20210207-225126","text":"Fix install-latest-clojure-lsp.sh script - #304 Fix clojure-lsp re-analysing classpath when project contains a keyword starting with a number - #305 Allow clj-kondo to pick up config correctly in mono repos - #303","title":"2021.02.07-22.51.26"},{"location":"CHANGELOG/#20210207-030431","text":"Make release's native binaries executable by default - #299 Improve completion removing the necessity to call completion/resolveItem - #292 New code action: Add suggested alias to namespaces - #302","title":"2021.02.07-03.04.31"},{"location":"CHANGELOG/#20210205-030534","text":"Add support for keyword analysis (definition, references, completion, rename, hover) Reduce jar and binaries size excluding some dependencies (Need to fix a lein issue yet)","title":"2021.02.05-03.05.34"},{"location":"CHANGELOG/#20210204-020858","text":"Fix --version on graalvm native compiled binaries","title":"2021.02.04-02.08.58"},{"location":"CHANGELOG/#20210204-010921","text":"Add integration tests to release process","title":"2021.02.04-01.09.21"},{"location":"CHANGELOG/#20210202-140223","text":"Fix clojure-lsp embedded jar binary during release CI Fix duplicate references on cljc files","title":"2021.02.02-14.02.23"},{"location":"CHANGELOG/#20210202-030646","text":"Add clojure.java.io to known requires - #291 Add manual System/gc after first classpath scan, it should decrease memory after the first startup Add support for Windows GraalVM compiled native binary","title":"2021.02.02-03.06.46"},{"location":"CHANGELOG/#20210201-203752","text":"Add native binaries for Linux and MacOS compiled with GraalVM #267 (Experimental)","title":"2021.02.01-20.37.52"},{"location":"CHANGELOG/#20210128-030316","text":"Fix clj-kondo batch analysis when merging batchs - Fix #284","title":"2021.01.28-03.03.16"},{"location":"CHANGELOG/#20210127-214742","text":"Fix missing printlng and avoid errors for next time (this was causing issues in clients like vim coc)","title":"2021.01.27-21.47.42"},{"location":"CHANGELOG/#20210126-223527","text":"Fix document-symbol after #261 - Fixes #276 Reduce memory usage on startup batch analyzing classpath via clj-kondo. - Fixes #268","title":"2021.01.26-22.35.27"},{"location":"CHANGELOG/#20210125-225605","text":"Do not remove document on textDocument/didClose , related to #264. Fix default project-specs for shadow-cljs to use npx prefix. Fix range of textDocument/hover for definition usages. Fix completionItem/resolve broken after #261.","title":"2021.01.25-22.56.05"},{"location":"CHANGELOG/#20210125-172205","text":"Remove references code-lens from deftest forms Fix completion for alias ns from external deps - Fixes #269","title":"2021.01.25-17.22.05"},{"location":"CHANGELOG/#20210122-130428","text":"Huge refactor https://github.com/clojure-lsp/clojure-lsp/pull/261 which uses clj-kondo analysis / findings output to almost all clojure-lsp features. Should significantly increase performance and startup time Should fix almost all bugs/issues with windows Users since we now rely on clj-kondo analysis Remove all lint configs from clojure-lsp including macro-defs , they should be configured on clj-kondo side now via .clj-kondo/config.edn Move file path on documentation to bottom","title":"2021.01.22-13.04.28"},{"location":"CHANGELOG/#20210120-013932","text":"Fixes args for extract-function refactoring - Fixes #263","title":"2021.01.20-01.39.32"},{"location":"CHANGELOG/#20210116-032820","text":"Check for defintions when finding references with includeDeclaration as true - Fixes #260 Add custom command cursor-info to debugging clojure-lsp. Fix unnecessary new-lines on imports when executing clean-ns","title":"2021.01.16-03.28.20"},{"location":"CHANGELOG/#20210114-231554","text":"Check for the whole line to add-miising-* code actions instead of expect the cursor at the ns to be required/imported - Fixes #258 Return all possible add-missing-* code actions to the same line.","title":"2021.01.14-23.15.54"},{"location":"CHANGELOG/#20210114-171910","text":"Fix add missing import code actions after refactor","title":"2021.01.14-17.19.10"},{"location":"CHANGELOG/#20210114-124442","text":"Fixes #208","title":"2021.01.14-12.44.42"},{"location":"CHANGELOG/#20210114-023028","text":"LSP 3.16: Add support for codeAction/resolve improving performance if client supports it Bump extend lib [CI] Remove auto release, next releases should contain more than one PR/fix","title":"2021.01.14-02.30.28"},{"location":"capabilities/","text":"Capabilities # Implementation Status # Below are all the currently supported LSP capabilities and their implementation status: capability done notes initialize \u221a initialized \u221a shutdown \u221a exit \u221a $/cancelRequest $/progress window/showMessage \u221a window/showMessageRequest window/logMessage window/workDoneProgress/create window/workDoneProgress/cancel telemetry/event client/registerCapability \u221a client/unregisterCapability workspace/workspaceFolders workspace/didChangeWorkspaceFolders workspace/didChangeConfiguration \u221a Currently does nothing but log workspace/configuration workspace/didChangeWatchedFiles \u221a workspace/symbol \u221a workspace/executeCommand \u221a See Extra capabilities workspace/applyEdit \u221a TextDocumentEdit and RenameFile only textDocument/didOpen \u221a textDocument/didChange \u221a textDocument/willSave textDocument/willSaveWaitUntil textDocument/didSave \u221a Do nothing currently textDocument/didClose \u221a textDocument/publishDiagnostics \u221a textDocument/completion \u221a completionItem/resolve \u221a textDocument/hover \u221a textDocument/signatureHelp \u221a Missing support for active parameter ATM textDocument/declaration textDocument/definition \u221a TODO: Find java classes definition textDocument/typeDefinition textDocument/implementation textDocument/references \u221a textDocument/documentHighlight \u221a textDocument/documentSymbol \u221a textDocument/codeAction \u221a codeAction/resolve \u221a textDocument/codeLens \u221a codeLens/resolve \u221a textDocument/documentLink documentLink/resolve textDocument/documentColor textDocument/colorPresentation textDocument/formatting \u221a textDocument/rangeFormatting \u221a textDocument/onTypeFormatting textDocument/rename \u221a textDocument/prepareRename textDocument/foldingRange textDocument/selectionRange textDocument/semanticTokens/full \u221a Just functions , type' and macros ATM textDocument/semanticTokens/full/delta textDocument/semanticTokens/range \u221a workspace/semanticTokens/refresh textDocument/linkedEditingRange textDocument/prepareCallHierarchy \u221a callHierarchy/incomingCalls \u221a callHierarchy/outgoingCalls \u221a textDocument/moniker Extra capabilities # Besides LSP official capabilities, clojure-lsp has some extra features: Refactorings # It should be possible to introduce most of the refactorings here More details # Calling executeCommand with the following commands and additional args will notify the client with applyEdit . All commands expect the first three args to be [document-uri, line, column] (eg [\"file:///home/snoe/file.clj\", 13, 11] ) done command args notes \u221a add-import-to-namespace [document-uri, line, column, import-name] \u221a add-missing-libspec \u221a clean-ns :require sort and remove unused \u221a cycle-coll \u221a cycle-privacy \u221a expand-let \u221a extract-function [document-uri, line, column, function-name] \u221a inline-symbol \u221a introduce-let [document-uri, line, column, binding-name] \u221a move-to-let [document-uri, line, column, binding-name] \u221a thread-first \u221a thread-first-all \u221a thread-last \u221a thread-last-all \u221a unwind-all \u221a unwind-thread See Vim client section for an example. Emacs provides all those refactorings via lsp-mode with the lsp-clojure- prefix. Other clients might provide a higher level interface to workspace/executeCommand you need to pass the path, line and column numbers. Custom commands # clojure-lsp has some custom commands: command args notes server-info Use to retrieve server and configuration information cursor-info [document-uri, line, column] Use to retrieve debugging information for the symbol at cursor","title":"Capabilities"},{"location":"capabilities/#capabilities","text":"","title":"Capabilities"},{"location":"capabilities/#implementation-status","text":"Below are all the currently supported LSP capabilities and their implementation status: capability done notes initialize \u221a initialized \u221a shutdown \u221a exit \u221a $/cancelRequest $/progress window/showMessage \u221a window/showMessageRequest window/logMessage window/workDoneProgress/create window/workDoneProgress/cancel telemetry/event client/registerCapability \u221a client/unregisterCapability workspace/workspaceFolders workspace/didChangeWorkspaceFolders workspace/didChangeConfiguration \u221a Currently does nothing but log workspace/configuration workspace/didChangeWatchedFiles \u221a workspace/symbol \u221a workspace/executeCommand \u221a See Extra capabilities workspace/applyEdit \u221a TextDocumentEdit and RenameFile only textDocument/didOpen \u221a textDocument/didChange \u221a textDocument/willSave textDocument/willSaveWaitUntil textDocument/didSave \u221a Do nothing currently textDocument/didClose \u221a textDocument/publishDiagnostics \u221a textDocument/completion \u221a completionItem/resolve \u221a textDocument/hover \u221a textDocument/signatureHelp \u221a Missing support for active parameter ATM textDocument/declaration textDocument/definition \u221a TODO: Find java classes definition textDocument/typeDefinition textDocument/implementation textDocument/references \u221a textDocument/documentHighlight \u221a textDocument/documentSymbol \u221a textDocument/codeAction \u221a codeAction/resolve \u221a textDocument/codeLens \u221a codeLens/resolve \u221a textDocument/documentLink documentLink/resolve textDocument/documentColor textDocument/colorPresentation textDocument/formatting \u221a textDocument/rangeFormatting \u221a textDocument/onTypeFormatting textDocument/rename \u221a textDocument/prepareRename textDocument/foldingRange textDocument/selectionRange textDocument/semanticTokens/full \u221a Just functions , type' and macros ATM textDocument/semanticTokens/full/delta textDocument/semanticTokens/range \u221a workspace/semanticTokens/refresh textDocument/linkedEditingRange textDocument/prepareCallHierarchy \u221a callHierarchy/incomingCalls \u221a callHierarchy/outgoingCalls \u221a textDocument/moniker","title":"Implementation Status"},{"location":"capabilities/#extra-capabilities","text":"Besides LSP official capabilities, clojure-lsp has some extra features:","title":"Extra capabilities"},{"location":"capabilities/#refactorings","text":"It should be possible to introduce most of the refactorings here","title":"Refactorings"},{"location":"capabilities/#more-details","text":"Calling executeCommand with the following commands and additional args will notify the client with applyEdit . All commands expect the first three args to be [document-uri, line, column] (eg [\"file:///home/snoe/file.clj\", 13, 11] ) done command args notes \u221a add-import-to-namespace [document-uri, line, column, import-name] \u221a add-missing-libspec \u221a clean-ns :require sort and remove unused \u221a cycle-coll \u221a cycle-privacy \u221a expand-let \u221a extract-function [document-uri, line, column, function-name] \u221a inline-symbol \u221a introduce-let [document-uri, line, column, binding-name] \u221a move-to-let [document-uri, line, column, binding-name] \u221a thread-first \u221a thread-first-all \u221a thread-last \u221a thread-last-all \u221a unwind-all \u221a unwind-thread See Vim client section for an example. Emacs provides all those refactorings via lsp-mode with the lsp-clojure- prefix. Other clients might provide a higher level interface to workspace/executeCommand you need to pass the path, line and column numbers.","title":"More details"},{"location":"capabilities/#custom-commands","text":"clojure-lsp has some custom commands: command args notes server-info Use to retrieve server and configuration information cursor-info [document-uri, line, column] Use to retrieve debugging information for the symbol at cursor","title":"Custom commands"},{"location":"clients/","text":"Clients # Clients are either editors with built in LSP support like Oni, or an appropriate plugin. Clients are responsible for launching the server, the server is a subprocess of your editor not a daemon. In general, make sure to configure the client to use stdio and a server launch command like ['/usr/local/bin/clojure-lsp'] . If that fails, you may need to have your client launch inside a shell, so use someting like ['bash', '-c', '/usr/local/bin/clojure-lsp'] . In windows you probably need to rename to clojure-lsp.bat . Vim # I prefer https://github.com/neoclide/coc.nvim but both http://github.com/autozimu/LanguageClient-neovim and https://github.com/prabirshrestha/vim-lsp work well. See my nvim/init.vim and coc-settings.json LanguageClient-neovim can be configure with: Refactorings: function ! Expand ( exp ) abort let l :result = expand ( a :exp ) return l :result == # '' ? '' : \"file://\" . l :result endfunction nnoremap < silent > crcc : call LanguageClient#workspace_executeCommand ( 'cycle-coll' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crth : call LanguageClient#workspace_executeCommand ( 'thread-first' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtt : call LanguageClient#workspace_executeCommand ( 'thread-last' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtf : call LanguageClient#workspace_executeCommand ( 'thread-first-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtl : call LanguageClient#workspace_executeCommand ( 'thread-last-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crml : call LanguageClient#workspace_executeCommand ( 'move-to-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > cril : call LanguageClient#workspace_executeCommand ( 'introduce-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > crel : call LanguageClient#workspace_executeCommand ( 'expand-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > cram : call LanguageClient#workspace_executeCommand ( 'add-missing-libspec' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > initializationOptions can be sent by setting: let g:LanguageClient_settingsPath=\".lsp/settings.json\" Project-local .lsp/settings.json would have content like: { \"initializationOptions\" : { \"source-paths\" : [ \"shared-src\" , \"src\" , \"test\" , \"dashboard/src\" ] , \"macro-defs\" : { \"project.macros/dofor\" : [ \"bindings\" , \"bound-elements\" ]}}} Further refactoring mappings include being able to invoke the (coc-codeaction-*) function to provide actions such as move to let , change coll to map and so on. nmap <silent> <Leader>cr <Plug>(coc-rename) nmap <silent> <Leader>cf <Plug>(coc-references) xmap <silent> <Leader>c <Plug>(coc-codeaction-selected) nmap <silent> <Leader>c <Plug>(coc-codeaction-line) nmap <silent> gd <Plug>(coc-definition) Emacs # lsp-mode has built in support for clojure-lsp . With use-package , add the following to your emacs config: ( use-package lsp-mode :ensure t :hook (( clojure-mode . lsp ) ( clojurec-mode . lsp ) ( clojurescript-mode . lsp )) :config ;; add paths to your local installation of project mgmt tools, like lein ( setenv \"PATH\" ( concat \"/usr/local/bin\" path-separator ( getenv \"PATH\" ))) ( dolist ( m ' ( clojure-mode clojurec-mode clojurescript-mode clojurex-mode )) ( add-to-list 'lsp-language-id-configuration ` ( , m . \"clojure\" ))) ( setq lsp-clojure-server-command ' ( \"/path/to/clojure-lsp\" ))) ;; Optional: In case `clojure-lsp` is not in your $PATH Optionally you can add lsp-ui for UI feedback and company-mode for completion: ( use-package lsp-ui :ensure t :commands lsp-ui-mode ) ( use-package company :ensure t ) In lsp-mode , lsp-clojure-server-command variable is available to override the command to start the clojure-lsp server, might be necessary to do this on a Windows environment. For a detailed guide on how to configure Emacs with LSP, check here For more lsp-mode clojure settings, check here Oni # Seems to work reasonably well but couldn't get rename to work reliably https://github.com/onivim/oni Intellij / Cursive # https://github.com/gtache/intellij-lsp tested only briefly. Visual Studio Code # Proof of concept: in the client-vscode directory in this repo. Calva extension includes clojure-lsp support. Atom # I tried making a client but my hello world attempt didn't seem to work. If someone wants to take this on, I'd be willing to package it here too.","title":"Clients"},{"location":"clients/#clients","text":"Clients are either editors with built in LSP support like Oni, or an appropriate plugin. Clients are responsible for launching the server, the server is a subprocess of your editor not a daemon. In general, make sure to configure the client to use stdio and a server launch command like ['/usr/local/bin/clojure-lsp'] . If that fails, you may need to have your client launch inside a shell, so use someting like ['bash', '-c', '/usr/local/bin/clojure-lsp'] . In windows you probably need to rename to clojure-lsp.bat .","title":"Clients"},{"location":"clients/#vim","text":"I prefer https://github.com/neoclide/coc.nvim but both http://github.com/autozimu/LanguageClient-neovim and https://github.com/prabirshrestha/vim-lsp work well. See my nvim/init.vim and coc-settings.json LanguageClient-neovim can be configure with: Refactorings: function ! Expand ( exp ) abort let l :result = expand ( a :exp ) return l :result == # '' ? '' : \"file://\" . l :result endfunction nnoremap < silent > crcc : call LanguageClient#workspace_executeCommand ( 'cycle-coll' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crth : call LanguageClient#workspace_executeCommand ( 'thread-first' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtt : call LanguageClient#workspace_executeCommand ( 'thread-last' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtf : call LanguageClient#workspace_executeCommand ( 'thread-first-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtl : call LanguageClient#workspace_executeCommand ( 'thread-last-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crml : call LanguageClient#workspace_executeCommand ( 'move-to-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > cril : call LanguageClient#workspace_executeCommand ( 'introduce-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > crel : call LanguageClient#workspace_executeCommand ( 'expand-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > cram : call LanguageClient#workspace_executeCommand ( 'add-missing-libspec' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > initializationOptions can be sent by setting: let g:LanguageClient_settingsPath=\".lsp/settings.json\" Project-local .lsp/settings.json would have content like: { \"initializationOptions\" : { \"source-paths\" : [ \"shared-src\" , \"src\" , \"test\" , \"dashboard/src\" ] , \"macro-defs\" : { \"project.macros/dofor\" : [ \"bindings\" , \"bound-elements\" ]}}} Further refactoring mappings include being able to invoke the (coc-codeaction-*) function to provide actions such as move to let , change coll to map and so on. nmap <silent> <Leader>cr <Plug>(coc-rename) nmap <silent> <Leader>cf <Plug>(coc-references) xmap <silent> <Leader>c <Plug>(coc-codeaction-selected) nmap <silent> <Leader>c <Plug>(coc-codeaction-line) nmap <silent> gd <Plug>(coc-definition)","title":"Vim"},{"location":"clients/#emacs","text":"lsp-mode has built in support for clojure-lsp . With use-package , add the following to your emacs config: ( use-package lsp-mode :ensure t :hook (( clojure-mode . lsp ) ( clojurec-mode . lsp ) ( clojurescript-mode . lsp )) :config ;; add paths to your local installation of project mgmt tools, like lein ( setenv \"PATH\" ( concat \"/usr/local/bin\" path-separator ( getenv \"PATH\" ))) ( dolist ( m ' ( clojure-mode clojurec-mode clojurescript-mode clojurex-mode )) ( add-to-list 'lsp-language-id-configuration ` ( , m . \"clojure\" ))) ( setq lsp-clojure-server-command ' ( \"/path/to/clojure-lsp\" ))) ;; Optional: In case `clojure-lsp` is not in your $PATH Optionally you can add lsp-ui for UI feedback and company-mode for completion: ( use-package lsp-ui :ensure t :commands lsp-ui-mode ) ( use-package company :ensure t ) In lsp-mode , lsp-clojure-server-command variable is available to override the command to start the clojure-lsp server, might be necessary to do this on a Windows environment. For a detailed guide on how to configure Emacs with LSP, check here For more lsp-mode clojure settings, check here","title":"Emacs"},{"location":"clients/#oni","text":"Seems to work reasonably well but couldn't get rename to work reliably https://github.com/onivim/oni","title":"Oni"},{"location":"clients/#intellij-cursive","text":"https://github.com/gtache/intellij-lsp tested only briefly.","title":"Intellij / Cursive"},{"location":"clients/#visual-studio-code","text":"Proof of concept: in the client-vscode directory in this repo. Calva extension includes clojure-lsp support.","title":"Visual Studio Code"},{"location":"clients/#atom","text":"I tried making a client but my hello world attempt didn't seem to work. If someone wants to take this on, I'd be willing to package it here too.","title":"Atom"},{"location":"features/","text":"Features # Above you can find all available features that clojure-lsp provide with examples using Emacs lsp-mode client. Find a function/var definition # Find all references of a function, var, keyword or namespace alias # Show all workspace/project symbols # Show all symbols on current file # Rename symbols # Document highlight on hover showing symbol usages # Code actions # Name Example Clean namespace require/imports Add missing require Add known common require Add known common import Add suggested alias require Inline symbol Extract function Move to let Change coll to map,vector,set,list Thread first/all last Create private function Resolve macro as... Code lenses showing symbol references # Format a whole file or range # Signature help # Semantic tokens # Experimental: apply color on client editor for each known token Call hierarchy # Show the incoming or outgoing call hierarchy of a function/variable as a lazy tree Incoming # Show functions that call the current one recursively Outgoing # Show functions that the current one call, recursively Execute command # Commands that client can request. Some code actions use these commands as actions. Refactoring # Commands that change/refactor the code, most of them are available via code actions. Clean namespace * # Add import to namespace # Add missing namespace * # Cycle privacy of def/defn # Cycle collection (#{}, {}, [], ()) # Change collection to {}, (), #{}, [] # Extract Function * # Create private function * # Inline Symbol * # Expand let # Introduce let # Move expression to let # Thread first expression # Thread last expression # Thread first all * # Thread last all * # Unwind all # Unwind thread # Resolve macro as * # This code action should be wrapped by the LSP client to provide the missing arguments beside the existing return by the code action: The macro which should resolve as e.g. clojure.core/def The clj-kondo configuration to save the new setting. e.g /home/user/.clj-kondo/config.edn For an example, check how Emacs LSP client handles that. * Available via code actions too Dev # Server information # Return basic information about the server. Cursor information # Return debug information about the element at point. Custom message to client during any server process # During some process, clojure-lsp send messages to client informing some proccess, warning or error. Diagnostics (linter) # Most linters come from clj-kondo that clojure-lsp uses under the hood to lint the code and retrieve the analysis to make most of features work. Below you can find the custom linters implemented on clojure-lsp side: unused-public-var # For more information on how to configure it, check the diagnostics settings section .","title":"Features"},{"location":"features/#features","text":"Above you can find all available features that clojure-lsp provide with examples using Emacs lsp-mode client.","title":"Features"},{"location":"features/#find-a-functionvar-definition","text":"","title":"Find a function/var definition"},{"location":"features/#find-all-references-of-a-function-var-keyword-or-namespace-alias","text":"","title":"Find all references of a function, var, keyword or namespace alias"},{"location":"features/#show-all-workspaceproject-symbols","text":"","title":"Show all workspace/project symbols"},{"location":"features/#show-all-symbols-on-current-file","text":"","title":"Show all symbols on current file"},{"location":"features/#rename-symbols","text":"","title":"Rename symbols"},{"location":"features/#document-highlight-on-hover-showing-symbol-usages","text":"","title":"Document highlight on hover showing symbol usages"},{"location":"features/#code-actions","text":"Name Example Clean namespace require/imports Add missing require Add known common require Add known common import Add suggested alias require Inline symbol Extract function Move to let Change coll to map,vector,set,list Thread first/all last Create private function Resolve macro as...","title":"Code actions"},{"location":"features/#code-lenses-showing-symbol-references","text":"","title":"Code lenses showing symbol references"},{"location":"features/#format-a-whole-file-or-range","text":"","title":"Format a whole file or range"},{"location":"features/#signature-help","text":"","title":"Signature help"},{"location":"features/#semantic-tokens","text":"Experimental: apply color on client editor for each known token","title":"Semantic tokens"},{"location":"features/#call-hierarchy","text":"Show the incoming or outgoing call hierarchy of a function/variable as a lazy tree","title":"Call hierarchy"},{"location":"features/#incoming","text":"Show functions that call the current one recursively","title":"Incoming"},{"location":"features/#outgoing","text":"Show functions that the current one call, recursively","title":"Outgoing"},{"location":"features/#execute-command","text":"Commands that client can request. Some code actions use these commands as actions.","title":"Execute command"},{"location":"features/#refactoring","text":"Commands that change/refactor the code, most of them are available via code actions.","title":"Refactoring"},{"location":"features/#clean-namespace","text":"","title":"Clean namespace *"},{"location":"features/#add-import-to-namespace","text":"","title":"Add import to namespace"},{"location":"features/#add-missing-namespace","text":"","title":"Add missing namespace *"},{"location":"features/#cycle-privacy-of-defdefn","text":"","title":"Cycle privacy of def/defn"},{"location":"features/#cycle-collection","text":"","title":"Cycle collection (#{}, {}, [], ())"},{"location":"features/#change-collection-to","text":"","title":"Change collection to {}, (), #{}, []"},{"location":"features/#extract-function","text":"","title":"Extract Function *"},{"location":"features/#create-private-function","text":"","title":"Create private function *"},{"location":"features/#inline-symbol","text":"","title":"Inline Symbol *"},{"location":"features/#expand-let","text":"","title":"Expand let"},{"location":"features/#introduce-let","text":"","title":"Introduce let"},{"location":"features/#move-expression-to-let","text":"","title":"Move expression to let"},{"location":"features/#thread-first-expression","text":"","title":"Thread first expression"},{"location":"features/#thread-last-expression","text":"","title":"Thread last expression"},{"location":"features/#thread-first-all","text":"","title":"Thread first all *"},{"location":"features/#thread-last-all","text":"","title":"Thread last all *"},{"location":"features/#unwind-all","text":"","title":"Unwind all"},{"location":"features/#unwind-thread","text":"","title":"Unwind thread"},{"location":"features/#resolve-macro-as","text":"This code action should be wrapped by the LSP client to provide the missing arguments beside the existing return by the code action: The macro which should resolve as e.g. clojure.core/def The clj-kondo configuration to save the new setting. e.g /home/user/.clj-kondo/config.edn For an example, check how Emacs LSP client handles that. * Available via code actions too","title":"Resolve macro as *"},{"location":"features/#dev","text":"","title":"Dev"},{"location":"features/#server-information","text":"Return basic information about the server.","title":"Server information"},{"location":"features/#cursor-information","text":"Return debug information about the element at point.","title":"Cursor information"},{"location":"features/#custom-message-to-client-during-any-server-process","text":"During some process, clojure-lsp send messages to client informing some proccess, warning or error.","title":"Custom message to client during any server process"},{"location":"features/#diagnostics-linter","text":"Most linters come from clj-kondo that clojure-lsp uses under the hood to lint the code and retrieve the analysis to make most of features work. Below you can find the custom linters implemented on clojure-lsp side:","title":"Diagnostics (linter)"},{"location":"features/#unused-public-var","text":"For more information on how to configure it, check the diagnostics settings section .","title":"unused-public-var"},{"location":"installation/","text":"Installation # Below are all available clojure-lsp installation methods, after installed, follow the documentation for your editor's language client. See Clients . Native binary (recommended) # clojure-lsp builds using GraalVM a native executable for each OS: Linux, MacOS and Windows. Manually # The binaries are available on Github releases as clojure-lsp-native-<os>-<arch>.zip , after downloading you just need to unzip it. Script # You can install it running ./install-latest-clojure-lsp.sh Embedded jar (Legacy executable) # In Github releases you will find a clojure-lsp file that runs a embedded jar. This should be removed soon, use GraalVM binaries instead. You need java on your $PATH. Grab the latest clojure-lsp from github LATEST Place it in your $PATH with a chmod 755 MacOS # We have a custom tap using the native compiled binaries for users that use homebrew: brew remove clojure-lsp # if you have old clojure-lsp installed via brew brew install clojure-lsp/brew/clojure-lsp-native Nix # clojure-lsp is available in the nixpkgs : nix-shell -p clojure-lsp Arch Linux # clojure-lsp is available in the Arch User Repository . It can be installed using your favorite AUR helper such as yay , yaourt , apacman and pacaur . Here is an example using yay : yay -S clojure-lsp-bin Windows # clojure-lsp is available as a native executable in the Clojure Scoop bucket . You need to install Scoop if you don't have it already. Issue following command to download the clojure-lsp executable. scoop install clojure-lsp","title":"Installation"},{"location":"installation/#installation","text":"Below are all available clojure-lsp installation methods, after installed, follow the documentation for your editor's language client. See Clients .","title":"Installation"},{"location":"installation/#native-binary-recommended","text":"clojure-lsp builds using GraalVM a native executable for each OS: Linux, MacOS and Windows.","title":"Native binary (recommended)"},{"location":"installation/#manually","text":"The binaries are available on Github releases as clojure-lsp-native-<os>-<arch>.zip , after downloading you just need to unzip it.","title":"Manually"},{"location":"installation/#script","text":"You can install it running ./install-latest-clojure-lsp.sh","title":"Script"},{"location":"installation/#embedded-jar-legacy-executable","text":"In Github releases you will find a clojure-lsp file that runs a embedded jar. This should be removed soon, use GraalVM binaries instead. You need java on your $PATH. Grab the latest clojure-lsp from github LATEST Place it in your $PATH with a chmod 755","title":"Embedded jar (Legacy executable)"},{"location":"installation/#macos","text":"We have a custom tap using the native compiled binaries for users that use homebrew: brew remove clojure-lsp # if you have old clojure-lsp installed via brew brew install clojure-lsp/brew/clojure-lsp-native","title":"MacOS"},{"location":"installation/#nix","text":"clojure-lsp is available in the nixpkgs : nix-shell -p clojure-lsp","title":"Nix"},{"location":"installation/#arch-linux","text":"clojure-lsp is available in the Arch User Repository . It can be installed using your favorite AUR helper such as yay , yaourt , apacman and pacaur . Here is an example using yay : yay -S clojure-lsp-bin","title":"Arch Linux"},{"location":"installation/#windows","text":"clojure-lsp is available as a native executable in the Clojure Scoop bucket . You need to install Scoop if you don't have it already. Issue following command to download the clojure-lsp executable. scoop install clojure-lsp","title":"Windows"},{"location":"settings/","text":"Settings # clojure-lsp settings are picked up on server start and can be configured via 3 ways: Project configuration Global configuration LSP InitializationOptions Project # clojure-lsp will look for project specific settings in a file called .lsp/config.edn . It will search from your project root folder up the directory structure so you can have multiple projects share the same settings. Example: { :cljfmt { :indents { # re \".*\" ns [[ :inner 0 ] [ :inner 1 ]]}} :auto-add-ns-to-new-files? false :project-specs [{ :project-path \"deps.edn\" :classpath-cmd [ \"clojure\" \"-A:dev\" \"-Spath\" ]}]} Global # For global settings which should work for all the projects using clojure-lsp , you just need to add the same configs to ~/.lsp/config.edn . For an example of a global config.edn , check here . InitializationOptions # This is specific for an client, where it sends on startup, check LSP spec for more information . This is an example how Emacs lsp-mode pass custom information. All settings # name description default source-paths project-local directories to look for clj/cljc/cljs files #{\"src\" \"test\"} linters clojure-lsp custom linters, check the diagnostics settings section below {:unused-public-ns {:level :info}} ignore-classpath-directories will not consider clojure files within the directories specified by your classpath. This is needed, for instance, if your build puts artifacts into resources or target that you want lsp to ignore. false use-metadata-for-privacy? Whether to use ^:private metadata for refactorings instead of defn- false keep-require-at-start? Whether to keep first require/import at the first line instead of inserting a new line before it when using clean-ns refactoring. false semantic-tokens? Whether to enable LSP semantic tokens server support for syntax highlighting. (Experimental) false show-docs-arity-on-same-line? Whether to keep the arity on the same line of the function on hover, useful for Emacs users. false auto-add-ns-to-new-files? Whether to automatically add the ns form in new blank files. true document-formatting? if true or not present, document formatting is provided. true document-range-formatting? if true or not present, document range formatting is provided. true text-document-sync-kind The sync kind during document changes, if client should send whole buffer or just related changes. Should be :full or :incremental :full dependency-scheme How the dependencies should be linked, jar will make urls compatible with java's JarURLConnection. You can have the client make an lsp extension request of clojure/dependencyContents with the jar uri and the server will return the jar entry's contents. Similar to java clients zip cljfmt Used for formatting, json encoded configuration for cljfmt {} project-specs A vector of a map with project-path and classpath-cmd , defining how clojure-lsp should find your project classpath. the project-path should be a file and the classpath-cmd the command to run to get the classpath Check the default here sqlite-db-path Where to store the project's analysis cache, used to speed up next clojure-lsp startup. A path relative to project root or an absolute path. .lsp/sqlite.db log-path A absolute path to a file where clojure-lsp should log. A JVM tmp path, usually /tmp/clojure-lsp.*.out Diagnostics (linter) # clj-kondo # clojure-lsp uses clj-kondo under the hood to lint the code and retrieve the analysis to make most of features work, you don't have to install clj-kondo to make it work, clojure-lsp will use a specific clj-kondo version that can be retrieved via clojure-lsp --version , but make sure you have it properly configured in your .clj-kondo/config.edn file. It has the possible key/values: :level with available values: :off , :on with default value of :on :report-duplicates which will show all linters of the same symbol instead of showing only the first spot. Available values: true , false with default value of true Example: { :linters { :clj-kondo { :level :off :report-duplicates false }}} For more information about available configurations, check the clj-kondo configuration section clojure-lsp # At the moment clojure-lsp has only the custom linters below: unused-public-var # This linter reports public functions/vars not used over the project. It has the possible key/values: :level with available values: :info , :warning , :error or :off with default value of :info . :exclude a whole namespace with #{my-ns} or a specific var #{my-ns/foo} . :exclude-when-defined-by excludes this linter when your var is defined by a macro for example, like #{my-ns/deftest} . Example: { :linters { :unused-public-var { :level :warning :exclude # { my-ns/foo my-ns/bar other-ns } :exclude-when-defined-by # { my-ns/defflow }}}} For information on how to troubleshoot the linter, check the troubleshooting section","title":"Settings"},{"location":"settings/#settings","text":"clojure-lsp settings are picked up on server start and can be configured via 3 ways: Project configuration Global configuration LSP InitializationOptions","title":"Settings"},{"location":"settings/#project","text":"clojure-lsp will look for project specific settings in a file called .lsp/config.edn . It will search from your project root folder up the directory structure so you can have multiple projects share the same settings. Example: { :cljfmt { :indents { # re \".*\" ns [[ :inner 0 ] [ :inner 1 ]]}} :auto-add-ns-to-new-files? false :project-specs [{ :project-path \"deps.edn\" :classpath-cmd [ \"clojure\" \"-A:dev\" \"-Spath\" ]}]}","title":"Project"},{"location":"settings/#global","text":"For global settings which should work for all the projects using clojure-lsp , you just need to add the same configs to ~/.lsp/config.edn . For an example of a global config.edn , check here .","title":"Global"},{"location":"settings/#initializationoptions","text":"This is specific for an client, where it sends on startup, check LSP spec for more information . This is an example how Emacs lsp-mode pass custom information.","title":"InitializationOptions"},{"location":"settings/#all-settings","text":"name description default source-paths project-local directories to look for clj/cljc/cljs files #{\"src\" \"test\"} linters clojure-lsp custom linters, check the diagnostics settings section below {:unused-public-ns {:level :info}} ignore-classpath-directories will not consider clojure files within the directories specified by your classpath. This is needed, for instance, if your build puts artifacts into resources or target that you want lsp to ignore. false use-metadata-for-privacy? Whether to use ^:private metadata for refactorings instead of defn- false keep-require-at-start? Whether to keep first require/import at the first line instead of inserting a new line before it when using clean-ns refactoring. false semantic-tokens? Whether to enable LSP semantic tokens server support for syntax highlighting. (Experimental) false show-docs-arity-on-same-line? Whether to keep the arity on the same line of the function on hover, useful for Emacs users. false auto-add-ns-to-new-files? Whether to automatically add the ns form in new blank files. true document-formatting? if true or not present, document formatting is provided. true document-range-formatting? if true or not present, document range formatting is provided. true text-document-sync-kind The sync kind during document changes, if client should send whole buffer or just related changes. Should be :full or :incremental :full dependency-scheme How the dependencies should be linked, jar will make urls compatible with java's JarURLConnection. You can have the client make an lsp extension request of clojure/dependencyContents with the jar uri and the server will return the jar entry's contents. Similar to java clients zip cljfmt Used for formatting, json encoded configuration for cljfmt {} project-specs A vector of a map with project-path and classpath-cmd , defining how clojure-lsp should find your project classpath. the project-path should be a file and the classpath-cmd the command to run to get the classpath Check the default here sqlite-db-path Where to store the project's analysis cache, used to speed up next clojure-lsp startup. A path relative to project root or an absolute path. .lsp/sqlite.db log-path A absolute path to a file where clojure-lsp should log. A JVM tmp path, usually /tmp/clojure-lsp.*.out","title":"All settings"},{"location":"settings/#diagnostics-linter","text":"","title":"Diagnostics (linter)"},{"location":"settings/#clj-kondo","text":"clojure-lsp uses clj-kondo under the hood to lint the code and retrieve the analysis to make most of features work, you don't have to install clj-kondo to make it work, clojure-lsp will use a specific clj-kondo version that can be retrieved via clojure-lsp --version , but make sure you have it properly configured in your .clj-kondo/config.edn file. It has the possible key/values: :level with available values: :off , :on with default value of :on :report-duplicates which will show all linters of the same symbol instead of showing only the first spot. Available values: true , false with default value of true Example: { :linters { :clj-kondo { :level :off :report-duplicates false }}} For more information about available configurations, check the clj-kondo configuration section","title":"clj-kondo"},{"location":"settings/#clojure-lsp","text":"At the moment clojure-lsp has only the custom linters below:","title":"clojure-lsp"},{"location":"settings/#unused-public-var","text":"This linter reports public functions/vars not used over the project. It has the possible key/values: :level with available values: :info , :warning , :error or :off with default value of :info . :exclude a whole namespace with #{my-ns} or a specific var #{my-ns/foo} . :exclude-when-defined-by excludes this linter when your var is defined by a macro for example, like #{my-ns/deftest} . Example: { :linters { :unused-public-var { :level :warning :exclude # { my-ns/foo my-ns/bar other-ns } :exclude-when-defined-by # { my-ns/defflow }}}} For information on how to troubleshoot the linter, check the troubleshooting section","title":"unused-public-var"},{"location":"troubleshooting/","text":"Troubleshooting # Below are the common issues ordered by the most important to specific ones: Server is not initializing # Make sure you have the most recent version of clojure-lsp Check if the executable is working running it from the command line, it should start up and start reading from stdin. Type {}\\n\\n and you should get something like: $ clojure-lsp {} Apr 12, 2019 7:07:02 AM org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer fireError SEVERE: Missing header Content-Length in input \"{} \" java.lang.IllegalStateException: Missing header Content-Length in input \"{}\"\"\"\" \"\"\" If that is ok, clojure-lsp logs to /tmp/clojure-lsp.*.out , so watch that file and start your editor. LSP Clients also generally have a way to trace server interactions. Turn that on and attach both server and client logs to an issue if it's not obvious what's going on. For example, if you are using neovim with CoC , first ensure that trace.server is set to verbose in your coc-settings.json file, e.g., \"languageserver\" : { \"clojure-lsp\" : { \"command\" : \"clojure-lsp\" , \"filetypes\" : [ \"clojure\" ], \"disableDiagnostics\" : true , \"rootPatterns\" : [ \"deps.edn\" , \"project.clj\" ], \"additionalSchemes\" : [ \"jar\" , \"zipfile\" ], \"trace.server\" : \"verbose\" , \"initializationOptions\" : { \"project-specs\" : [{ \"project-path\" : \"deps.edn\" , \"classpath-cmd\" : [ \"clj\" , \"-Spath\" ] }], \"use-metadata-for-privacy?\" : true , \"ignore-classpath-directories\" : true } } } Then, once vim has loaded (and clojure-lsp has initialised), you can issue this command: :CocCommand workspace.showOutput This will show the JSON request/response bodies that go between vim and clojure-lsp. Please capture that information if you need help in tracking down the problem you are experiencing (either by reporting github issues, or talking with someone in Slack/Discord or whatever...) Some features are not working # clojure-lsp uses clj-kondo to scan the classpath during server initialize for most features work, so make sure you don't see any \"Error while looking up classpath...\" on clojure-lsp log file. Classpath scan error # By default clojure-lsp knows how to scan most common clojure projects using the following rules: If the project root has a project.clj file, it'll run lein classpath to get the classpath. If the project root has a deps.edn file, it'll run clojure -Spath to get the classpath. If the project root has a build.boot file, it'll run boot show --fake-classpath to get the classpath. If the project root has a shadow-cljs.edn file, it'll run npx shadow-cljs classpath to get the classpath. If your project doesn't follow the above rules or you need a custom command to get the classpath you need to configure the project-specs clojure-lsp setting, for more details check the settings section . Folders not being analyzed # By default clojure-lsp searches src and test for clj* files to read into an index. If the definition lives under a different source dir, you can define the src-paths setting, for more details check the settings section . It is also important to get your project-root correct in your client otherwise the source paths will not be found, check the project-root via your LSP client. Wrong diagnostics/lint # clojure-lsp persist the external jars analysis in a .lsp/sqlite.db file, if you have issues with some specific feature, try to remove that file and restart the server. clojure-lsp use clj-kondo to lint and cache in a .clj-kondo/.cache dir, try to remove that file as well if you think it's not linting correctly If you have issues with macros, double check your clj-kondo config . MacOS # In some version of MacOS, Apple restrict the binary to run, to fix that run: xattr -d com.apple.quarantine /path/to/clojure-lsp","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"Below are the common issues ordered by the most important to specific ones:","title":"Troubleshooting"},{"location":"troubleshooting/#server-is-not-initializing","text":"Make sure you have the most recent version of clojure-lsp Check if the executable is working running it from the command line, it should start up and start reading from stdin. Type {}\\n\\n and you should get something like: $ clojure-lsp {} Apr 12, 2019 7:07:02 AM org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer fireError SEVERE: Missing header Content-Length in input \"{} \" java.lang.IllegalStateException: Missing header Content-Length in input \"{}\"\"\"\" \"\"\" If that is ok, clojure-lsp logs to /tmp/clojure-lsp.*.out , so watch that file and start your editor. LSP Clients also generally have a way to trace server interactions. Turn that on and attach both server and client logs to an issue if it's not obvious what's going on. For example, if you are using neovim with CoC , first ensure that trace.server is set to verbose in your coc-settings.json file, e.g., \"languageserver\" : { \"clojure-lsp\" : { \"command\" : \"clojure-lsp\" , \"filetypes\" : [ \"clojure\" ], \"disableDiagnostics\" : true , \"rootPatterns\" : [ \"deps.edn\" , \"project.clj\" ], \"additionalSchemes\" : [ \"jar\" , \"zipfile\" ], \"trace.server\" : \"verbose\" , \"initializationOptions\" : { \"project-specs\" : [{ \"project-path\" : \"deps.edn\" , \"classpath-cmd\" : [ \"clj\" , \"-Spath\" ] }], \"use-metadata-for-privacy?\" : true , \"ignore-classpath-directories\" : true } } } Then, once vim has loaded (and clojure-lsp has initialised), you can issue this command: :CocCommand workspace.showOutput This will show the JSON request/response bodies that go between vim and clojure-lsp. Please capture that information if you need help in tracking down the problem you are experiencing (either by reporting github issues, or talking with someone in Slack/Discord or whatever...)","title":"Server is not initializing"},{"location":"troubleshooting/#some-features-are-not-working","text":"clojure-lsp uses clj-kondo to scan the classpath during server initialize for most features work, so make sure you don't see any \"Error while looking up classpath...\" on clojure-lsp log file.","title":"Some features are not working"},{"location":"troubleshooting/#classpath-scan-error","text":"By default clojure-lsp knows how to scan most common clojure projects using the following rules: If the project root has a project.clj file, it'll run lein classpath to get the classpath. If the project root has a deps.edn file, it'll run clojure -Spath to get the classpath. If the project root has a build.boot file, it'll run boot show --fake-classpath to get the classpath. If the project root has a shadow-cljs.edn file, it'll run npx shadow-cljs classpath to get the classpath. If your project doesn't follow the above rules or you need a custom command to get the classpath you need to configure the project-specs clojure-lsp setting, for more details check the settings section .","title":"Classpath scan error"},{"location":"troubleshooting/#folders-not-being-analyzed","text":"By default clojure-lsp searches src and test for clj* files to read into an index. If the definition lives under a different source dir, you can define the src-paths setting, for more details check the settings section . It is also important to get your project-root correct in your client otherwise the source paths will not be found, check the project-root via your LSP client.","title":"Folders not being analyzed"},{"location":"troubleshooting/#wrong-diagnosticslint","text":"clojure-lsp persist the external jars analysis in a .lsp/sqlite.db file, if you have issues with some specific feature, try to remove that file and restart the server. clojure-lsp use clj-kondo to lint and cache in a .clj-kondo/.cache dir, try to remove that file as well if you think it's not linting correctly If you have issues with macros, double check your clj-kondo config .","title":"Wrong diagnostics/lint"},{"location":"troubleshooting/#macos","text":"In some version of MacOS, Apple restrict the binary to run, to fix that run: xattr -d com.apple.quarantine /path/to/clojure-lsp","title":"MacOS"}]}